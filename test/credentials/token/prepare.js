"use strict";

const sinon = require("sinon");

describe("perpareToken", function () {
  let fakes, prepareToken;

  beforeEach(function () {
    fakes = {
      sign: sinon.stub(),
      resolve: sinon.stub(),
    };

    prepareToken = require("../../../lib/credentials/token/prepare")(fakes);
  });

  const testOptions = {
    key: "key.pem",
    keyId: "123KeyId",
    teamId: "abcTeamId",
  };

  context("with valid options", function() {
    let generator;

    beforeEach(function() {
      fakes.resolve.withArgs("key.pem").returns("keyData");
      fakes.sign.returns("generated-token")

      generator = prepareToken(testOptions);
    });

    describe("return value", function (){
      it("is a function", function () {
        expect(typeof generator).to.equal("function");
      });

      it("invokes the sign method with the correct arguments", function () {
        generator();

        expect(fakes.sign).to.have.been.calledWith(
          sinon.match({}), // empty payload
          "keyData", 
          sinon.match({
            algorithm: "ES256",
            issuer: "abcTeamId",
            header: sinon.match({
              kid: "123KeyId",
            })
          })
        );
      });

      it("returns the token generated by the sign method", function () {
        expect(generator()).to.equal("generated-token");
      });
    });
  });

  context("with bad `key` parameter", function () {
    context("key resolution fails", function () {
      it("throws a wrapped error", function () {
        fakes.resolve.withArgs("key.pem").throws(new Error("ENOENT: Unable to read file key.pem"));

        expect(() => prepareToken(testOptions)).to.throw(/Failed loading token key: ENOENT: Unable to read file key.pem/);
      });
    });

    context("key cannot be used for signing", function () {
      xit("throws a wrapped error from jwt.sign", function () {

      }); // Call sign once to check if something throws
    });
  });
});
